package com.viaplay.historicalamendment;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGenerateStrategy;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedTimestamp;
import com.amazonaws.services.dynamodbv2.document.*;
import com.amazonaws.services.dynamodbv2.document.spec.GetItemSpec;
import com.amazonaws.services.dynamodbv2.model.*;
import com.viaplay.historicalamendment.model.RecordDao;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Date;
import java.util.HashMap;
import java.util.concurrent.CompletableFuture;

@Component
public class UpmWatchedRecordProcessor implements RecordProcessor {


    private Table upmWatchedTable = null;

    @Autowired
    private DynamoDB dynamoDB;

    private Date createdDate;

    @Autowired
    private ApplicationConfig config;


    @PostConstruct
    public void preLoadDataBases() {
        upmWatchedTable = dynamoDB.getTable(config.getUserProgramMarksWatched());
    }


    private Timestamp now() {
        return new Timestamp(System.currentTimeMillis());
    }

    @DynamoDBAutoGeneratedTimestamp(strategy= DynamoDBAutoGenerateStrategy.CREATE)
    public Date getCreatedDate() { return createdDate; }


    private boolean shouldUpdateRecordForUPM(String hashkey,  String rawProgramGuid) {
        Item upmRecordExists = null;
        try{
            GetItemSpec itemSpec = new GetItemSpec()
                    .withPrimaryKey(new PrimaryKey("userId", hashkey, "programGuid", rawProgramGuid));
             upmRecordExists = upmWatchedTable.getItem(itemSpec);
            if(upmRecordExists != null){
                System.out.println(upmRecordExists.toJSONPretty());

            }
        } catch(Exception ex){
            System.out.println(ex.getMessage());
        }

        return upmRecordExists !=null ? false:true;
    }


    @Override
    public <T> CompletableFuture<T> createUpdateQuery(RecordDao recordDao) {


        return (CompletableFuture<T>) CompletableFuture.supplyAsync(() -> {

            System.out.println("from UPM watched  ");
            String hashKey = createHashKey(recordDao);
          if(!shouldUpdateRecordForUPM(hashKey, recordDao.getProgramGuid())){
                //to avoid duplicates
                  return null;
           }
            HashMap<String, AttributeValue> upmWatchedValues = new HashMap<>();
            upmWatchedValues.put("userId", new AttributeValue(hashKey));
            upmWatchedValues.put("programGuid", new AttributeValue(recordDao.getProgramGuid()));
            upmWatchedValues.put("metadata", new AttributeValue("{}"));
            String timeStampStr= recordDao.getTimestamp();
            System.out.println("---------raw timestamp ----" +  timeStampStr);
            Timestamp timeStampLong = StringUtils.isNoneEmpty(timeStampStr) ? new Timestamp(Long.valueOf(timeStampStr)): now();
            AttributeValue timeStamoValue = new AttributeValue();
            timeStamoValue.setN(String.valueOf(timeStampLong.getTime()));
            upmWatchedValues.put("ts",timeStamoValue);
            System.out.println("---------processed timestamp ----" +  timeStampLong.getTime());

            String primary = "userId";
            String secondary = "programGuid";

            return new Put()
                    .withTableName(config.getUserProgramMarksWatched())
                    .withItem(upmWatchedValues)
                    .withConditionExpression("attribute_not_exists(" + primary + ") and attribute_not_exists(" + secondary + ")");






        });


    }
}

